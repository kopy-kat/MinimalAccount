/// @title MinimalAccount
/// @notice Gas optimized minimal ERC-4337 account
/// @author kopy-kat <https://github.com/kopy-kat>
/// @custom:inspiration SimpleAccount <https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/samples/SimpleAccount.sol>
/// @custom:inspiration Huffmate <https://github.com/huff-language/huffmate>

/* Interface */
#define function execute(address,uint256,bytes) nonpayable returns ()

/* Constants */
#define constant ENTRYPOINT_ADDRESS = 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789
#define constant OWNER_ADDRESS = 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf // replaced by the factory

///@dev The number which `s` must not exceed in order for the signature to be non-malleable
#define constant MALLEABILITY_THRESHOLD = 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0

///@dev Ethereum Signed Message header
#define constant SIG_HEADER = 0x0000000019457468657265756d205369676e6564204d6573736167653a0a3332

#define macro MAIN() = takes (0) returns (0) {
    calldatasize iszero finish jumpi
    // check entrypoint
    caller [ENTRYPOINT_ADDRESS] eq iszero notEntryPoint jumpi
    0x00 calldataload 0xE0 shr
    dup1 0x3a871cdd eq validate jumpi
    dup1 __FUNC_SIG(execute) eq execute jumpi

    validate:
        // mstore userOpHash to scratch space
        0x20                     // [0x20]
        dup1                     // [hashSize, 0x20]
        0x24                     // [hashOffset, hashSize, 0x20]
        dup2                     // [hashMemOffset, hashOffset, hashSize, 0x20]
        calldatacopy             // [0x20]
        // mstore SIG_HEADER to scratch space
        [SIG_HEADER] 0x00 mstore // [0x20]
        // mstore newHash to 0x00
        0x3c 0x04 sha3           // [newHash, 0x20]
        0x00                     // [0x00, newHash, 0x20]
        mstore                   // [0x20]
        // reset 0x20
        0x00                     // [0x00, 0x20]
        dup2                     // [0x20, 0x00, 0x20]
        mstore                   // [0x20]

        // signature verification
        // get sSlot to verify s value 
        0x41                     // [0x41, 0x20]
        0x1a4 calldataload       // [sigSlot, 0x41, 0x20]
        0xa5 add                 // [sSlot, 0x41, 0x20]
        // If `s` is not in lower half order, such that the signature is malleable,
        // jump to `zero`.
        dup1 calldataload        // [s, sSlot, 0x41, 0x20]
        [MALLEABILITY_THRESHOLD] // [malleability_threshold, s, sSlot, 0x41, 0x20]
        swap1                    // [s, malleability_threshold, sSlot, 0x41, 0x20]
        gt                       // [s > malleability_threshold, sSlot, 0x41, 0x20]
        invalidSignature jumpi   // [sSlot, 0x41, 0x20]

        // mstore signature(v,r,s) to 0x3f
        0x21                     // [0x21, sSlot, 0x41, 0x20]
        swap1                    // [sSlot, 0x21, 0x41, 0x20]
        sub                      // [vSlot, 0x41, 0x20]
        0x3f                     // [0x3f, vSlot, 0x41, 0x20]
        calldatacopy             // [0x20]
        dup1                     // [0x20, 0x20]

        0x40 0x80 0x00 0x01      // [0x01, 0x00, 0x80, 0x40, 0x20, 0x20]
        gas staticcall pop       // [0x20]

        returndatasize 0x60 sub  // [0x60 - returndatasize, 0x20]
        mload                    // [result, 0x20]

        [OWNER_ADDRESS] eq iszero invalidSignature jumpi // [0x20]

        // 3. Pay prefund
        0x44 calldataload           // [value, 0x20]
        dup1                        // [value, value, 0x20]
        iszero noPrefund jumpi      // [value, 0x20]

        0x00                        // [retOffset, value]
        0x00                        // [retSize, retOffset, value]
        0x00                        // [argSize, retOffset, retSize, value]
        0x00                        // [argOffset, argSize, retOffset, retSize, value]
        swap4                       // [value, argOffset, argSize, retOffset, retSize]
        caller                      // [target, value, argOffset, argSize, retOffset, retSize]
        gas                         // [gas, target, value, argOffset, argSize, retOffset, retSize]
        call                        // [success]

        noPrefund:                  // [value, 0x20]
          dup2 0x80                 
          return
    execute:
        0x64 calldataload           // [argSize]
        dup1                        // [argSize, argSize]
        0x84                        // [offset, argSize, argSize]
        callvalue                   // [destOffset, offset, argSize, argSize]
        calldatacopy                // [argSize]

        callvalue                   // [retOffset, argSize]
        0x20                        // [retSize, retOffset, argSize]
        swap2                       // [argSize, retOffset, retSize]
        callvalue                   // [argOffset, argSize, retOffset, retSize]
        0x24 calldataload           // [value, argOffset, argSize, retOffset, retSize]
        0x04 calldataload           // [target, value, argOffset, argSize, retOffset, retSize]
        gas                         // [gas, target, value, argOffset, argSize, retOffset, retSize]
        call                        // [success]
    finish:
        stop
    invalidSignature:
        0x01 0x00 mstore
        0x20 0x00 return
    notEntryPoint:
        0x00 0x00 revert
}
